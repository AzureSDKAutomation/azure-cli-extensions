# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddAdlsGen2FileDataSet(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.adls_gen2_file_data_set = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'file-system':
                d['file_system'] = v[0]
            elif kl == 'storage-account-id':
                d['storage_account_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter adls_gen2_file_data_set. All possible '
                               'keys are: file-path, file-system, storage-account-id'.format(k))
        d['kind'] = 'AdlsGen2File'
        return d


class AddAdlsGen2FileSystemDataSet(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.adls_gen2_file_system_data_set = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'file-system':
                d['file_system'] = v[0]
            elif kl == 'storage-account-id':
                d['storage_account_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter adls_gen2_file_system_data_set. All '
                               'possible keys are: file-system, storage-account-id'.format(k))
        d['kind'] = 'AdlsGen2FileSystem'
        return d


class AddAdlsGen2FolderDataSet(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.adls_gen2_folder_data_set = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'file-system':
                d['file_system'] = v[0]
            elif kl == 'folder-path':
                d['folder_path'] = v[0]
            elif kl == 'storage-account-id':
                d['storage_account_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter adls_gen2_folder_data_set. All possible '
                               'keys are: file-system, folder-path, storage-account-id'.format(k))
        d['kind'] = 'AdlsGen2Folder'
        return d


class AddBlobContainerDataSet(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.blob_container_data_set = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'container-name':
                d['container_name'] = v[0]
            elif kl == 'storage-account-id':
                d['storage_account_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter blob_container_data_set. All possible '
                               'keys are: container-name, storage-account-id'.format(k))
        d['kind'] = 'Container'
        return d


class AddBlobDataSet(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.blob_data_set = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'container-name':
                d['container_name'] = v[0]
            elif kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'storage-account-id':
                d['storage_account_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter blob_data_set. All possible keys are: '
                               'container-name, file-path, storage-account-id'.format(k))
        d['kind'] = 'Blob'
        return d


class AddBlobFolderDataSet(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.blob_folder_data_set = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'container-name':
                d['container_name'] = v[0]
            elif kl == 'prefix':
                d['prefix'] = v[0]
            elif kl == 'storage-account-id':
                d['storage_account_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter blob_folder_data_set. All possible keys '
                               'are: container-name, prefix, storage-account-id'.format(k))
        d['kind'] = 'BlobFolder'
        return d


class AddSynapseSparkPipelineStep(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.synapse_spark_pipeline_step = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'dependencies':
                d['dependencies'] = v
            elif kl == 'executor-node-size':
                d['executor_node_size'] = v[0]
            elif kl == 'executors-count':
                d['executors_count'] = v[0]
            elif kl == 'script-id':
                d['script_id'] = v[0]
            elif kl == 'script-revision':
                d['script_revision'] = v[0]
            elif kl == 'script-sink-bindings':
                d['script_sink_bindings'] = v
            elif kl == 'script-source-bindings':
                d['script_source_bindings'] = v
            elif kl == 'synapse-spark-pool-id':
                d['synapse_spark_pool_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter synapse_spark_pipeline_step. All possible '
                               'keys are: dependencies, executor-node-size, executors-count, script-id, '
                               'script-revision, script-sink-bindings, script-source-bindings, synapse-spark-pool-id'.
                               format(k))
        d['kind'] = 'SynapseSpark'
        return d


class AddLocationConstraint(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.location_constraint = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'location':
                d['location'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter location_constraint. All possible keys '
                               'are: description, location'.format(k))
        d['kind'] = 'Location'
        return d


class AddScriptConstraint(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.script_constraint = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'script-reference-id':
                d['script_reference_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter script_constraint. All possible keys are: '
                               'description, script-reference-id'.format(k))
        d['kind'] = 'Script'
        return d


class AddDiagnosticPolicy(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.diagnostic_policy = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'log-level':
                d['log_level'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter diagnostic_policy. All possible keys are: '
                               'description, log-level'.format(k))
        d['kind'] = 'DiagnosticLevel'
        return d


class AddSynapseSparkScript(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.synapse_spark_script = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'content':
                d['content'] = v[0]
            elif kl == 'language':
                d['language'] = v[0]
            elif kl == 'sinks':
                d['sinks'] = v
            elif kl == 'sources':
                d['sources'] = v
            elif kl == 'visibility':
                d['visibility'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter synapse_spark_script. All possible keys '
                               'are: content, language, sinks, sources, visibility'.format(k))
        d['kind'] = 'SynapseSpark'
        return d
